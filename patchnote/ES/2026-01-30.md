# Optimización, escalabilidad y seguridad del portfolio

Esta actualización aplica una gran limpieza técnica: menos código duplicado, una API más robusta, un rate limit compartido entre instancias y un refuerzo de la seguridad en todo el sitio y en las rutas API.

Fecha: 30 de enero de 2026

## Optimización del código (DRY)

### Tipos y constantes de GitHub

- **RepoParam**: el tipo **{ owner, name }** estaba definido por triplicado en las rutas multi-stats, multi-timeline y multi-commits. Ahora se define una sola vez en **lib/github/types.ts** y se reutiliza en todas partes.
- **Períodos válidos**: la lista **['7d', '30d', '6m', '12m']** se copiaba en más de siete sitios (rutas API, componentes, utils). Una única constante **VALID_TIME_RANGES** sirve ahora como referencia para la validación y la visualización de los períodos.
- **Fecha de inicio de un rango**: la misma lógica existía duplicada (**getStartDate** en db-queries y **getStartDateForRange** en utils). Todo pasa por **getStartDateForRange** para evitar cualquier divergencia.

> Por qué: un solo lugar que modificar si se añade o cambia un período, y menos riesgo de error.

### Parseo de parámetros en rutas multi-repo

- Las tres rutas (multi-stats, multi-timeline, multi-commits) repetían el mismo bloque: lectura de **repos**, **range**, **locale**, validación del range, parseo JSON de repos, fallback hacia los repos permitidos y filtro de repos válidos.
- Una función única **parseMultiRepoQueryParams** en **lib/github/route-params.ts** centraliza esta lógica y devuelve o bien los parámetros validados, o bien una respuesta de error 400.

> Por qué: un cambio de regla (p. ej., una nueva validación) se hace en un solo sitio.

### Respuestas API seguras

- Cada ruta envolvía manualmente las respuestas con **addSecurityHeaders** y el rate limit restante, lo que multiplicaba los olvidos y el código repetitivo.
- Un helper **createJsonResponse(data, options, securityCheck)** aplica de forma sistemática las cabeceras de seguridad y el rate limit restante.

> Por qué: respuestas homogéneas y menos riesgo de olvidar un header.

### Barras de navegación de secciones

- Las cuatro navbars (Stats, FAQ, Juegos, Proyectos) tenían la misma estructura: barra fija, logo/avatar, enlaces (Inicio, FAQ, Stats, Juegos), parámetros y menú móvil.
- Un componente común **SectionNavigation** recibe la lista de enlaces y el componente de menú móvil. Cada página (Stats, FAQ, etc.) lo usa aportando solo sus enlaces y su menú.

> Por qué: un cambio de estilo o de estructura de la barra se hace una sola vez.

### Limpieza

- Eliminación del bloque vacío en multi-commits (condición **if (allCommits.length === 0)** sin cuerpo).
- Orígenes autorizados (CORS): posibilidad de configurarlos vía las variables de entorno **ALLOWED_ORIGINS** o **NEXT_PUBLIC_SITE_URL**, con fallback a una lista por defecto.
- Labels de períodos en los tipos: sustituidos por claves neutras; la visualización para el usuario sigue gestionada por i18n (traducciones de 7 días, 30 días, etc.).

---

## Escalabilidad

### Rate limit de las API de GitHub

- El rate limit de las rutas GitHub (multi-stats, multi-timeline, multi-commits, etc.) usaba un **Map en memoria**. En multi-instancia o en serverless, cada instancia tenía su propio contador, así que no había un límite global.
- Ahora el rate limit se apoya en **Redis** (como para el email) cuando Redis está disponible, con fallback a memoria si no. El límite se comparte entre todas las instancias.

> Por qué: en producción con varias instancias, el número de peticiones por IP queda correctamente limitado.

---

## Seguridad

### Extracción de la IP del cliente

- La lógica de extracción de la IP (cf-connecting-ip, x-forwarded-for, x-real-ip) estaba duplicada en **lib/github/security.ts** y **lib/rate-limit.ts**.
- Una sola función **getClientIP(request)** en **lib/request-utils.ts** se usa tanto para la seguridad de GitHub como para el rate limit del email.

> Por qué: una única fuente de verdad para la identificación del cliente.

### Errores API centralizados

- Los mensajes de error de las rutas mezclaban francés e inglés y estaban dispersos en cada fichero.
- Un módulo **lib/github/errors.ts** centraliza códigos, mensajes (en inglés para la API) y estados HTTP. Las rutas usan **apiError('CODE', options)** para devolver respuestas de error coherentes.

> Por qué: una API más profesional y un mantenimiento más simple.

### Validación de parámetros

- **Rutas multi-repo**: tamaño máximo del parámetro **repos** (4 KB), número máximo de repos (20), formato estricto para **owner** y **name** (alfanumérico, guion, guion bajo, 1–100 caracteres). La locale se limita a **fr** o **en**.
- **API Patchnotes**: validación del **id** para impedir la traversée de répertoires (path traversal). Solo se aceptan identificadores del tipo **FR/2026-01-30** o **EN/2026-01-30**; se verifica que la ruta resuelta se mantenga dentro de la carpeta de patchnotes.
- **Búsqueda de commits**: el parámetro de búsqueda **q** se limita a 128 caracteres.
- **Webhook de GitHub**: tamaño máximo del body a 1 MB (respuesta 413 si se supera). Verificación de la firma HMAC con comparación de longitudes antes de **timingSafeEqual** para evitar fugas por timing. Uso de **getClientIP** compartido para la verificación de las IP de GitHub.

### Cabeceras de seguridad del sitio

- Añadida una **Content-Security-Policy** en la config de Next.js: restricción de las fuentes por defecto, de formularios, frames, imágenes y scripts, con autorización explícita para Turnstile (Cloudflare) y EmailJS.

> Por qué: reducir la superficie de ataque XSS y las cargas no deseadas.

---

## Gráfico: solo períodos de 7 días y 30 días

### Contexto

- En 6 meses y 12 meses, el gráfico de actividad de commits daba problemas de visualización: tooltip a 0 al pasar el ratón, línea de hover desalineada respecto a los meses de abajo y un render poco legible.
- En 7 días y 30 días, la visualización y el hover se mantienen correctos.

### Cambios

- **Gráfico**: el selector de período del gráfico (encima de la curva) ya solo ofrece **7 días** y **30 días**. Una constante **CHART_TIME_RANGES** = **['7d', '30d']** se usa únicamente para este selector.
- **Stats globales**: el selector de período de las stats (commits, líneas, contribuidores, etc.) conserva **7 días, 30 días, 6 meses y 12 meses** (**VALID_TIME_RANGES**). El valor por defecto sigue siendo **12 meses**.
- **Búsqueda de commits**: el selector de período de la búsqueda mantiene **7 días, 30 días, 6 meses y 12 meses**.

> Por qué: mantener 6m y 12m donde son útiles (cifras y búsqueda) y evitar bugs de visualización en el gráfico ofreciendo solo 7d y 30d para la curva.

---

## Resumen técnico

| Dominio              | Archivos / zonas impactadas                                                                 |
|----------------------|---------------------------------------------------------------------------------------------|
| Tipos / constantes   | **lib/github/types.ts**, **utils.ts**, **db-queries.ts**, rutas API multi-*, PeriodSelector, página stats |
| Params / seguridad   | **lib/github/route-params.ts**, **security.ts**, rutas API GitHub, patchnotes               |
| Rate limit / IP      | **lib/github/security.ts**, **lib/rate-limit.ts**, **lib/request-utils.ts**                 |
| Errores API          | **lib/github/errors.ts**, todas las rutas API implicadas                                    |
| Navbars              | **SectionNavigation.tsx**, StatsNavigation, FAQNavigation, GamesNavigation, ProjectsNavigation |
| Seguridad            | **next.config.ts** (CSP), validación id/lang/sort patchnotes, webhook, límite **q**         |
| Gráfico              | **CHART_TIME_RANGES** en types, página stats (solo selector del gráfico)                    |

---

## Para el usuario

- **No cambia nada en el uso**: sigues eligiendo tus repos y tus períodos para las stats y la búsqueda de commits como antes.
- **Gráfico**: encima del gráfico, solo se proponen las opciones «7 días» y «30 días» para una visualización limpia; las stats globales y la búsqueda de commits mantienen 6 meses y 12 meses.
- **Seguridad**: las API y el sitio aplican validaciones y cabeceras reforzadas, sin modificar el flujo normal de uso.